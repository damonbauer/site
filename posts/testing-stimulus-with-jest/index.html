<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="description" content="Testing Stimulus With Jest" />
    <title>Testing Stimulus With Jest</title>
    <style type="text/css">body{max-width:600px;font-size:20px}</style>
  </head>
  <body>
    <header>
      <a href="/">damon bauer's blog</a><br>
      <span>developer, amateur woodworker</span>
    </header><br><br>

    <small>2019-11-03</small>
    <h1 style="margin-top:0">
      Testing Stimulus With Jest
    </h1>
    <p>I've been introducing <a href="https://stimulusjs.org/">Stimulus</a> to a Rails app that uses <a href="https://jestjs.io/">Jest</a> for testing JavaScript. After some research, I've found a pretty decent setup that allows me to load up a Stimulus controller to writes tests. If you need to do the same, here are some things you'll need, as well as some nice-to-haves.</p>
<h3>MutationObserver</h3>
<p>Stimulus relies on <code>MutationObserver</code>, but Jest (which uses jsdom under the hood) doesn't support it, so you'll need to fake it. Thankfully, there's a <a href="https://www.npmjs.com/package/%60mutationobserver-shim%60">mutationobserver-shim</a> that handles it for you. Install it by running <code>yarn i mutationobserver-shim --dev</code>.</p>
<p>You'll also need a Jest setup script. I like to make a <code>setup-jest.js</code> file in the root of my project. Inside, import the shim:</p>
<pre><code class="language-js">// ./setup-jest.js
import 'mutationobserver-shim';
</code></pre>
<p>Make sure you configure Jest to look for this file. I like to make a <code>jest-config.js</code> file in the root of my project; this file holds all the configuration I need for Jest. Set the <code>setupFilesAfterEnv</code> option to look for the setup file:</p>
<pre><code class="language-js">// ./jest-config.js
// other config...
setupFilesAfterEnv: [
  '&lt;rootDir&gt;/setup-jest.js'
]
</code></pre>
<h3>Writing A Test</h3>
<p>Now, it's just a matter of including your Stimulus controller in your test. To do so, you'll need to import and &quot;start&quot; Stimulus, and register your controller that you want to test:</p>
<pre><code class="language-js">import { Application } from 'stimulus';
import HelloWorldController from '../../controllers/hello_world_controller';

const startStimulus = () =&gt; {
  const application = Application.start();
  application.register('hello-world', HelloWorldController);
};

describe('the file under test', () =&gt; {
  beforeEach(() =&gt; {
    startStimulus();
    document.body.innerHtml = `
      &lt;form data-controller=&quot;hello-world&quot;&gt;
        &lt;input type=&quot;text&quot; data-testid=&quot;Foo&quot;&gt;
        &lt;button name=&quot;button&quot; type=&quot;submit&quot; disabled=&quot;disabled&quot;&gt;Verify&lt;/button&gt;
      &lt;/form&gt;
    `
  });

  describe('a scenario', () =&gt; {
    it('tests the scenario', () =&gt; {
      // ...
    });
  });
});
</code></pre>
<h3>Nice To Haves</h3>
<h4>dom-testing-library</h4>
<p>I like to use <a href="https://testing-library.com/docs/dom-testing-library/intro">dom-testing-library</a> to make accessing &amp; manipulating the DOM easier in tests. When writing tests for Stimulus controllers, I've found that <code>getByTestId</code> and <code>waitForDomChange</code> are 2 especially helpful methods.</p>
<h4>mountDOM / cleanupDOM</h4>
<p>I wrote a few quick helper methods that make it easy to add &amp; remove markup from the DOM. These live in a <code>utils.js</code> file in <code>app/javascript/__tests__/utils.js</code>.</p>
<pre><code class="language-js">// app/javascript/__tests__/utils.js

/**
 * Inserts a string of HTML into the DOM.
 * @param {string} htmlString - The HTML to insert.
 * @returns {HTMLElement} The newly inserted DOM element.
 */
const mountDOM = (htmlString = '') =&gt; {
  const div = document.createElement('div');
  div.innerHTML = htmlString;
  document.body.appendChild(div);

  return div;
};

const cleanupDOM = () =&gt; {
  document.body.innerHTML = '';
};

export {
  cleanupDOM,
  mountDOM
};
</code></pre>
<p>Typically, a test I write will use these methods like so:</p>
<pre><code class="language-js">let container = null;

describe('the file under test', () =&gt; {
  afterEach(() =&gt; {
    cleanupDOM();
  });

  describe('a scenario', () =&gt; {
    it('tests the scenario', () =&gt; {
      container = mountDOM(`
        &lt;form data-controller=&quot;hello-world&quot;&gt;
          &lt;input type=&quot;text&quot; data-testid=&quot;Foo&quot;&gt;
          &lt;button name=&quot;button&quot; type=&quot;submit&quot; disabled=&quot;disabled&quot;&gt;Verify&lt;/button&gt;
        &lt;/form&gt;
      `);

      // Continue with the test...
    });
  });
</code></pre>

    <a href="/">‚Üê Back</a>
  </body>
</html>
